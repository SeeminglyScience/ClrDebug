using System.Collections.Generic;

namespace ClrDebug.Native
{
    internal class CorError
    {
        public const int E_NOINTERFACE = unchecked((int)0x80004002);

        public const int E_POINTER = unchecked((int)0x80004003);

        public const string NoResourceStringMessage = "An error has occurred.";

        public const string NoResourceIdMessage = "UnknownCorError";

        public static readonly Dictionary<long, (string Id, string Message)> s_errorMap = new Dictionary<long, (string Id, string Message)>()
        {
            { 0x131106, ("CLDB_S_TRUNCATION", "STATUS: Data value was truncated.") },
            { 0x131197, ("META_S_DUPLICATE", "Attempt to define an object that already exists in valid scenerios.") },
            { 0x13130b, ("CORDBG_S_BAD_START_SEQUENCE_POINT", "Attempt to SetIP not at a sequence point sequence point.") },
            { 0x13130c, ("CORDBG_S_BAD_END_SEQUENCE_POINT", "Attempt to SetIP when not going to a sequence point. If both this and CORDBG_E_BAD_START_SEQUENCE_POINT are true, only CORDBG_E_BAD_START_SEQUENCE_POINT will be reported.") },
            { 0x131316, ("CORDBG_S_FUNC_EVAL_HAS_NO_RESULT", "Some Func evals will lack a return value,") },
            { 0x131317, ("CORDBG_S_VALUE_POINTS_TO_VOID", "The Debugging API doesn't support dereferencing void pointers.") },
            { 0x131319, ("CORDBG_S_FUNC_EVAL_ABORTED", "The func eval completed, but was aborted.") },
            { 0x131324, ("CORDBG_S_AT_END_OF_STACK", "The stack walk has reached the end of the stack.  There are no more frames to walk.") },
            { 0x131c13, ("CORDBG_S_NOT_ALL_BITS_SET", "Not all bits specified were successfully applied") },
            { 0x80131001, ("CEE_E_CVTRES_NOT_FOUND", "cvtres.exe not found.") },
            { 0x80131013, ("COR_E_TYPEUNLOADED", "Type has been unloaded.") },
            { 0x80131014, ("COR_E_APPDOMAINUNLOADED", "Attempted to access an unloaded appdomain.") },
            { 0x80131015, ("COR_E_CANNOTUNLOADAPPDOMAIN", "Error while unloading appdomain.") },
            { 0x80131016, ("MSEE_E_ASSEMBLYLOADINPROGRESS", "Assembly is still being loaded.") },
            { 0x80131018, ("COR_E_ASSEMBLYEXPECTED", "The module was expected to contain an assembly manifest.") },
            { 0x80131019, ("COR_E_FIXUPSINEXE", "Attempt to load an unverifiable executable with fixups (IAT with more than 2 sections or a TLS section.)") },
            { 0x8013101b, ("COR_E_NEWER_RUNTIME", "This assembly is built by a runtime newer than the currently loaded runtime and cannot be loaded.") },
            { 0x8013101e, ("COR_E_MULTIMODULEASSEMBLIESDIALLOWED", "The module cannot be loaded because only single file assemblies are supported.") },
            { 0x80131020, ("HOST_E_DEADLOCK", "Host detected a deadlock on a blocking operation.") },
            { 0x80131022, ("HOST_E_INVALIDOPERATION", "Invalid operation.") },
            { 0x80131023, ("HOST_E_CLRNOTAVAILABLE", "CLR has been disabled due to unrecoverable error.") },
            { 0x80131027, ("HOST_E_EXITPROCESS_THREADABORT", "Process exited due to ThreadAbort escalation.") },
            { 0x80131028, ("HOST_E_EXITPROCESS_ADUNLOAD", "Process exited due to AD Unload escalation.") },
            { 0x80131029, ("HOST_E_EXITPROCESS_TIMEOUT", "Process exited due to Timeout escalation.") },
            { 0x8013102a, ("HOST_E_EXITPROCESS_OUTOFMEMORY", "Process exited due to OutOfMemory escalation.") },
            { 0x80131039, ("COR_E_MODULE_HASH_CHECK_FAILED", "The check of the module's hash failed.") },
            { 0x80131040, ("FUSION_E_REF_DEF_MISMATCH", "The located assembly's manifest definition does not match the assembly reference.") },
            { 0x80131041, ("FUSION_E_INVALID_PRIVATE_ASM_LOCATION", "The private assembly was located outside the appbase directory.") },
            { 0x80131042, ("FUSION_E_ASM_MODULE_MISSING", "A module specified in the manifest was not found.") },
            { 0x80131044, ("FUSION_E_PRIVATE_ASM_DISALLOWED", "A strongly-named assembly is required.") },
            { 0x80131045, ("FUSION_E_SIGNATURE_CHECK_FAILED", "Strong name signature could not be verified.  The assembly may have been tampered with, or it was delay signed but not fully signed with the correct private key.") },
            { 0x80131047, ("FUSION_E_INVALID_NAME", "The given assembly name or codebase was invalid.") },
            { 0x80131048, ("FUSION_E_CODE_DOWNLOAD_DISABLED", "HTTP download of assemblies has been disabled for this appdomain.") },
            { 0x80131050, ("FUSION_E_HOST_GAC_ASM_MISMATCH", "Assembly in host store has a different signature than assembly in GAC.") },
            { 0x80131051, ("FUSION_E_LOADFROM_BLOCKED", "LoadFrom(), LoadFile(), Load(byte[]) and LoadModule() have been disabled by the host.") },
            { 0x80131052, ("FUSION_E_CACHEFILE_FAILED", "Failed to add file to AppDomain cache.") },
            { 0x80131053, ("FUSION_E_APP_DOMAIN_LOCKED", "The requested assembly version conflicts with what is already bound in the app domain or specified in the manifest.") },
            { 0x80131054, ("FUSION_E_CONFIGURATION_ERROR", "The requested assembly name was neither found in the GAC nor in the manifest or the manifest's specified location is wrong.") },
            { 0x80131055, ("FUSION_E_MANIFEST_PARSE_ERROR", "Unexpected error while parsing the specified manifest.") },
            { 0x80131058, ("COR_E_LOADING_REFERENCE_ASSEMBLY", "Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context.") },
            { 0x80131059, ("COR_E_NI_AND_RUNTIME_VERSION_MISMATCH", "The native image could not be loaded, because it was generated for use by a different version of the runtime.") },
            { 0x80131069, ("COR_E_LOADING_WINMD_REFERENCE_ASSEMBLY", "Contract Windows Runtime assemblies cannot be loaded for execution.  Make sure your application only contains non-contract Windows Runtime assemblies.") },
            { 0x8013106A, ("COR_E_AMBIGUOUSIMPLEMENTATION", "Ambiguous implementation found.") },
            { 0x80131100, ("CLDB_E_FILE_BADREAD", "Error occurred during a read.") },
            { 0x80131101, ("CLDB_E_FILE_BADWRITE", "Error occurred during a write.") },
            { 0x80131107, ("CLDB_E_FILE_OLDVER", "Old version error.") },
            { 0x8013110a, ("CLDB_E_SMDUPLICATE", "Create of shared memory failed.  A memory mapping of the same name already exists.") },
            { 0x8013110b, ("CLDB_E_NO_DATA", "No .CLB data in the memory or stream.") },
            { 0x8013110d, ("CLDB_E_INCOMPATIBLE", "Importing scope is not compatible with the emitting scope.") },
            { 0x8013110e, ("CLDB_E_FILE_CORRUPT", "File is corrupt.") },
            { 0x80131110, ("CLDB_E_BADUPDATEMODE", "Cannot open a incrementally build scope for full update.") },
            { 0x80131124, ("CLDB_E_INDEX_NOTFOUND", "Index not found.") },
            { 0x80131130, ("CLDB_E_RECORD_NOTFOUND", "Record not found on lookup.") },
            { 0x80131135, ("CLDB_E_RECORD_OUTOFORDER", "Record is emitted out of order.") },
            { 0x80131154, ("CLDB_E_TOO_BIG", "A blob or string was too big.") },
            { 0x8013115f, ("META_E_INVALID_TOKEN_TYPE", "A token of the wrong type passed to a metadata function.") },
            { 0x80131165, ("TLBX_E_LIBNOTREGISTERED", "Typelib export: Type library is not registered.") },
            { 0x8013118a, ("META_E_BADMETADATA", "Merge: Inconsistency in meta data import scope.") },
            { 0x80131192, ("META_E_BAD_SIGNATURE", "Bad binary signature.") },
            { 0x80131193, ("META_E_BAD_INPUT_PARAMETER", "Bad input parameters.") },
            { 0x80131196, ("META_E_CANNOTRESOLVETYPEREF", "Cannot resolve typeref.") },
            { 0x80131198, ("META_E_STRINGSPACE_FULL", "No logical space left to create more user strings.") },
            { 0x8013119a, ("META_E_HAS_UNMARKALL", "Unmark all has been called already.") },
            { 0x8013119b, ("META_E_MUST_CALL_UNMARKALL", "Must call UnmarkAll first before marking.") },
            { 0x801311c0, ("META_E_CA_INVALID_TARGET", "Known custom attribute on invalid target.") },
            { 0x801311c1, ("META_E_CA_INVALID_VALUE", "Known custom attribute had invalid value.") },
            { 0x801311c2, ("META_E_CA_INVALID_BLOB", "Known custom attribute blob has bad format.") },
            { 0x801311c3, ("META_E_CA_REPEATED_ARG", "Known custom attribute blob has repeated named argument.") },
            { 0x801311c4, ("META_E_CA_UNKNOWN_ARGUMENT", "Known custom attribute named argument not recognized.") },
            { 0x801311c7, ("META_E_CA_UNEXPECTED_TYPE", "Known attribute parser found unexpected type.") },
            { 0x801311c8, ("META_E_CA_INVALID_ARGTYPE", "Known attribute parser only handles fields, not properties.") },
            { 0x801311c9, ("META_E_CA_INVALID_ARG_FOR_TYPE", "Known attribute parser found an argument that is invalid for the object it is applied to.") },
            { 0x801311ca, ("META_E_CA_INVALID_UUID", "The format of the UUID was invalid.") },
            { 0x801311cb, ("META_E_CA_INVALID_MARSHALAS_FIELDS", "The MarshalAs attribute has fields set that are not valid for the specified unmanaged type.") },
            { 0x801311cc, ("META_E_CA_NT_FIELDONLY", "The specified unmanaged type is only valid on fields.") },
            { 0x801311cd, ("META_E_CA_NEGATIVE_PARAMINDEX", "The parameter index cannot be negative.") },
            { 0x801311cf, ("META_E_CA_NEGATIVE_CONSTSIZE", "The constant size cannot be negative.") },
            { 0x801311d0, ("META_E_CA_FIXEDSTR_SIZE_REQUIRED", "A fixed string requires a size.") },
            { 0x801311d1, ("META_E_CA_CUSTMARSH_TYPE_REQUIRED", "A custom marshaler requires the custom marshaler type.") },
            { 0x801311d4, ("META_E_NOT_IN_ENC_MODE", "SaveDelta was called without being in EnC mode.") },
            { 0x801311e5, ("META_E_CA_BAD_FRIENDS_ARGS", "InternalsVisibleTo can't have a version, culture, or processor architecture.") },
            { 0x801311e6, ("META_E_CA_FRIENDS_SN_REQUIRED", "Strong-name signed assemblies can only grant friend access to strong name-signed assemblies") },
            { 0x80131203, ("VLDTR_E_RID_OUTOFRANGE", "Rid is out of range.") },
            { 0x80131206, ("VLDTR_E_STRING_INVALID", "String offset is invalid.") },
            { 0x80131207, ("VLDTR_E_GUID_INVALID", "GUID offset is invalid.") },
            { 0x80131208, ("VLDTR_E_BLOB_INVALID", "Blob offset if invalid.") },
            { 0x80131224, ("VLDTR_E_MR_BADCALLINGCONV", "MemberRef has invalid calling convention.") },
            { 0x80131237, ("VLDTR_E_SIGNULL", "Signature specified is zero-sized.") },
            { 0x80131239, ("VLDTR_E_MD_BADCALLINGCONV", "Method signature has invalid calling convention.") },
            { 0x8013123a, ("VLDTR_E_MD_THISSTATIC", "Method is marked static but has HASTHIS/EXPLICITTHIS set on the calling convention.") },
            { 0x8013123b, ("VLDTR_E_MD_NOTTHISNOTSTATIC", "Method is not marked static but is not HASTHIS or EXPLICITTHIS.") },
            { 0x8013123c, ("VLDTR_E_MD_NOARGCNT", "Method signature is missing the argument count.") },
            { 0x8013123d, ("VLDTR_E_SIG_MISSELTYPE", "Signature missing element type.") },
            { 0x8013123e, ("VLDTR_E_SIG_MISSTKN", "Signature missing token.") },
            { 0x8013123f, ("VLDTR_E_SIG_TKNBAD", "Signature has bad token.") },
            { 0x80131240, ("VLDTR_E_SIG_MISSFPTR", "Signature is missing function pointer.") },
            { 0x80131241, ("VLDTR_E_SIG_MISSFPTRARGCNT", "Signature has function pointer missing argument count.") },
            { 0x80131242, ("VLDTR_E_SIG_MISSRANK", "Signature is missing rank specification.") },
            { 0x80131243, ("VLDTR_E_SIG_MISSNSIZE", "Signature is missing count of sized dimensions.") },
            { 0x80131244, ("VLDTR_E_SIG_MISSSIZE", "Signature is missing size of dimension.") },
            { 0x80131245, ("VLDTR_E_SIG_MISSNLBND", "Signature is missing count of lower bounds.") },
            { 0x80131246, ("VLDTR_E_SIG_MISSLBND", "Signature is missing a lower bound.") },
            { 0x80131247, ("VLDTR_E_SIG_BADELTYPE", "Signature has bad element type.") },
            { 0x80131256, ("VLDTR_E_TD_ENCLNOTNESTED", "TypeDef not nested has encloser.") },
            { 0x80131277, ("VLDTR_E_FMD_PINVOKENOTSTATIC", "Field or method is PInvoke but is not marked Static.") },
            { 0x801312df, ("VLDTR_E_SIG_SENTINMETHODDEF", "E_T_SENTINEL in MethodDef signature.") },
            { 0x801312e0, ("VLDTR_E_SIG_SENTMUSTVARARG", "E_T_SENTINEL <=> VARARG.") },
            { 0x801312e1, ("VLDTR_E_SIG_MULTSENTINELS", "Multiple E_T_SENTINELs.") },
            { 0x801312e3, ("VLDTR_E_SIG_MISSARG", "Signature missing argument.") },
            { 0x801312e4, ("VLDTR_E_SIG_BYREFINFIELD", "Field of ByRef type.") },
            { 0x80131300, ("CORDBG_E_UNRECOVERABLE_ERROR", "Unrecoverable API error.") },
            { 0x80131301, ("CORDBG_E_PROCESS_TERMINATED", "Process was terminated.") },
            { 0x80131302, ("CORDBG_E_PROCESS_NOT_SYNCHRONIZED", "Process not synchronized.") },
            { 0x80131303, ("CORDBG_E_CLASS_NOT_LOADED", "A class is not loaded.") },
            { 0x80131304, ("CORDBG_E_IL_VAR_NOT_AVAILABLE", "An IL variable is not available at the current native IP.") },
            { 0x80131305, ("CORDBG_E_BAD_REFERENCE_VALUE", "A reference value was found to be bad during dereferencing.") },
            { 0x80131306, ("CORDBG_E_FIELD_NOT_AVAILABLE", "A field in a class is not available, because the runtime optimized it away.") },
            { 0x80131307, ("CORDBG_E_NON_NATIVE_FRAME", "'Native-frame-only' operation on non-native frame.") },
            { 0x80131309, ("CORDBG_E_CODE_NOT_AVAILABLE", "The code is currently unavailable.") },
            { 0x8013130a, ("CORDBG_E_FUNCTION_NOT_IL", "Attempt to get a ICorDebugFunction for a function that is not IL.") },
            { 0x8013130e, ("CORDBG_E_CANT_SET_IP_INTO_FINALLY", "SetIP is not possible because SetIP would move EIP from outside of an exception handling finally clause to a point inside of one.") },
            { 0x8013130f, ("CORDBG_E_CANT_SET_IP_OUT_OF_FINALLY", "SetIP is not possible because it would move EIP from within an exception handling finally clause to a point outside of one.") },
            { 0x80131310, ("CORDBG_E_CANT_SET_IP_INTO_CATCH", "SetIP is not possible, because SetIP would move EIP from outside of an exception handling catch clause to a point inside of one.") },
            { 0x80131311, ("CORDBG_E_SET_IP_NOT_ALLOWED_ON_NONLEAF_FRAME", "SetIP cannot be done on any frame except the leaf frame.") },
            { 0x80131312, ("CORDBG_E_SET_IP_IMPOSSIBLE", "SetIP is not allowed.") },
            { 0x80131313, ("CORDBG_E_FUNC_EVAL_BAD_START_POINT", "Func eval cannot work. Bad starting point.") },
            { 0x80131314, ("CORDBG_E_INVALID_OBJECT", "This object value is no longer valid.") },
            { 0x80131315, ("CORDBG_E_FUNC_EVAL_NOT_COMPLETE", "CordbEval::GetResult called before func eval has finished.") },
            { 0x8013131a, ("CORDBG_E_STATIC_VAR_NOT_AVAILABLE", "A static variable is not available because it has not been initialized yet.") },
            { 0x8013131c, ("CORDBG_E_CANT_SETIP_INTO_OR_OUT_OF_FILTER", "SetIP cannot leave or enter a filter.") },
            { 0x8013131d, ("CORDBG_E_CANT_CHANGE_JIT_SETTING_FOR_ZAP_MODULE", "JIT settings for ZAP modules cannot be changed.") },
            { 0x8013131e, ("CORDBG_E_CANT_SET_IP_OUT_OF_FINALLY_ON_WIN64", "SetIP is not possible because it would move EIP from within a finally clause to a point outside of one on this platforms.") },
            { 0x8013131f, ("CORDBG_E_CANT_SET_IP_OUT_OF_CATCH_ON_WIN64", "SetIP is not possible because it would move EIP from within a catch clause to a point outside of one on this platforms.") },
            { 0x80131323, ("CORDBG_E_CANT_SET_TO_JMC", "Cannot use JMC on this code (likely wrong JIT settings).") },
            { 0x80131325, ("CORDBG_E_NO_CONTEXT_FOR_INTERNAL_FRAME", "Internal frame markers have no associated context.") },
            { 0x80131326, ("CORDBG_E_NOT_CHILD_FRAME", "The current frame is not a child frame.") },
            { 0x80131327, ("CORDBG_E_NON_MATCHING_CONTEXT", "The provided CONTEXT does not match the specified thread.") },
            { 0x80131328, ("CORDBG_E_PAST_END_OF_STACK", "The stackwalker is now past the end of stack.  No information is available.") },
            { 0x80131329, ("CORDBG_E_FUNC_EVAL_CANNOT_UPDATE_REGISTER_IN_NONLEAF_FRAME", "Func eval cannot update a variable stored in a register on a non-leaf frame.  The most likely cause is that such a variable is passed as a ref/out argument.") },
            { 0x8013132d, ("CORDBG_E_BAD_THREAD_STATE", "The state of the thread is invalid.") },
            { 0x8013132e, ("CORDBG_E_DEBUGGER_ALREADY_ATTACHED", "This process has already been attached.") },
            { 0x8013132f, ("CORDBG_E_SUPERFLOUS_CONTINUE", "Returned from a call to Continue that was not matched with a stopping event.") },
            { 0x80131330, ("CORDBG_E_SET_VALUE_NOT_ALLOWED_ON_NONLEAF_FRAME", "Cannot perfrom SetValue on non-leaf frames.") },
            { 0x80131332, ("CORDBG_E_ENC_MODULE_NOT_ENC_ENABLED", "Tried to do Edit and Continue on a module that was not started in Edit and Continue mode.") },
            { 0x80131333, ("CORDBG_E_SET_IP_NOT_ALLOWED_ON_EXCEPTION", "SetIP cannot be done on any exception.") },
            { 0x80131334, ("CORDBG_E_VARIABLE_IS_ACTUALLY_LITERAL", "The 'variable' does not exist because it is a literal optimized away by the compiler.") },
            { 0x80131335, ("CORDBG_E_PROCESS_DETACHED", "Process has been detached.") },
            { 0x80131338, ("CORDBG_E_ENC_CANT_ADD_FIELD_TO_VALUE_OR_LAYOUT_CLASS", "Adding a field to a value or layout class is prohibited.") },
            { 0x8013133b, ("CORDBG_E_FIELD_NOT_STATIC", "GetStaticFieldValue called on a non-static field.") },
            { 0x8013133c, ("CORDBG_E_FIELD_NOT_INSTANCE", "Returned if someone tries to call GetStaticFieldValue on a non-instance field.") },
            { 0x8013133f, ("CORDBG_E_ENC_JIT_CANT_UPDATE", "The JIT is unable to update the method.") },
            { 0x80131341, ("CORDBG_E_ENC_INTERNAL_ERROR", "Internal Runtime Error while doing Edit-and-Continue.") },
            { 0x80131342, ("CORDBG_E_ENC_HANGING_FIELD", "The field was added via Edit and Continue after the class was loaded.") },
            { 0x80131343, ("CORDBG_E_MODULE_NOT_LOADED", "Module not loaded.") },
            { 0x80131345, ("CORDBG_E_UNABLE_TO_SET_BREAKPOINT", "Cannot set a breakpoint here.") },
            { 0x80131346, ("CORDBG_E_DEBUGGING_NOT_POSSIBLE", "Debugging is not possible due to an incompatibility within the CLR implementation.") },
            { 0x80131347, ("CORDBG_E_KERNEL_DEBUGGER_ENABLED", "A kernel debugger is enabled on the system.  User-mode debugging will trap to the kernel debugger.") },
            { 0x80131348, ("CORDBG_E_KERNEL_DEBUGGER_PRESENT", "A kernel debugger is present on the system.  User-mode debugging will trap to the kernel debugger.") },
            { 0x8013134b, ("CORDBG_E_INCOMPATIBLE_PROTOCOL", "The debugger's protocol is incompatible with the debuggee.") },
            { 0x8013134c, ("CORDBG_E_TOO_MANY_PROCESSES", "The debugger can only handle a finite number of debuggees.") },
            { 0x8013134d, ("CORDBG_E_INTEROP_NOT_SUPPORTED", "Interop debugging is not supported.") },
            { 0x8013134e, ("CORDBG_E_NO_REMAP_BREAKPIONT", "Cannot call RemapFunction until have received RemapBreakpoint.") },
            { 0x8013134f, ("CORDBG_E_OBJECT_NEUTERED", "Object is in a zombie state.") },
            { 0x80131350, ("CORPROF_E_FUNCTION_NOT_COMPILED", "Function not yet compiled.") },
            { 0x80131351, ("CORPROF_E_DATAINCOMPLETE", "The ID is not fully loaded/defined yet.") },
            { 0x80131354, ("CORPROF_E_FUNCTION_NOT_IL", "The Method has no associated IL.") },
            { 0x80131355, ("CORPROF_E_NOT_MANAGED_THREAD", "The thread has never run managed code before.") },
            { 0x80131356, ("CORPROF_E_CALL_ONLY_FROM_INIT", "The function may only be called during profiler initialization.") },
            { 0x8013135b, ("CORPROF_E_NOT_YET_AVAILABLE", "Requested information is not yet available.") },
            { 0x8013135c, ("CORPROF_E_TYPE_IS_PARAMETERIZED", "The given type is a generic and cannot be used with this method.") },
            { 0x8013135d, ("CORPROF_E_FUNCTION_IS_PARAMETERIZED", "The given function is a generic and cannot be used with this method.") },
            { 0x8013135e, ("CORPROF_E_STACKSNAPSHOT_INVALID_TGT_THREAD", "A profiler tried to walk the stack of an invalid thread") },
            { 0x8013135f, ("CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX", "A profiler can not walk a thread that is currently executing unmanaged code") },
            { 0x80131360, ("CORPROF_E_STACKSNAPSHOT_UNSAFE", "A stackwalk at this point may cause dead locks or data corruption") },
            { 0x80131361, ("CORPROF_E_STACKSNAPSHOT_ABORTED", "Stackwalking callback requested the walk to abort") },
            { 0x80131362, ("CORPROF_E_LITERALS_HAVE_NO_ADDRESS", "Returned when asked for the address of a static that is a literal.") },
            { 0x80131363, ("CORPROF_E_UNSUPPORTED_CALL_SEQUENCE", "A call was made at an unsupported time.  Examples include illegally calling a profiling API method asynchronously, calling a method that might trigger a GC at an unsafe time, and calling a method at a time that could cause locks to be taken out of order.") },
            { 0x80131364, ("CORPROF_E_ASYNCHRONOUS_UNSAFE", "A legal asynchronous call was made at an unsafe time (e.g., CLR locks are held)") },
            { 0x80131365, ("CORPROF_E_CLASSID_IS_ARRAY", "The specified ClassID cannot be inspected by this function because it is an array") },
            { 0x80131366, ("CORPROF_E_CLASSID_IS_COMPOSITE", "The specified ClassID is a non-array composite type (e.g., ref) and cannot be inspected") },
            { 0x80131367, ("CORPROF_E_PROFILER_DETACHING", "The profiler's call into the CLR is disallowed because the profiler is attempting to detach.") },
            { 0x80131368, ("CORPROF_E_PROFILER_NOT_ATTACHABLE", "The profiler does not support attaching to a live process.") },
            { 0x80131369, ("CORPROF_E_UNRECOGNIZED_PIPE_MSG_FORMAT", "The message sent on the profiling API attach pipe is in an unrecognized format.") },
            { 0x8013136A, ("CORPROF_E_PROFILER_ALREADY_ACTIVE", "The request to attach a profiler was denied because a profiler is already loaded.") },
            { 0x8013136B, ("CORPROF_E_PROFILEE_INCOMPATIBLE_WITH_TRIGGER", "Unable to request a profiler attach because the target profilee's runtime is of a version incompatible with the current process calling AttachProfiler().") },
            { 0x8013136C, ("CORPROF_E_IPC_FAILED", "AttachProfiler() encountered an error while communicating on the pipe to the target profilee.  This is often caused by a target profilee that is shutting down or killed while AttachProfiler() is reading or writing the pipe.") },
            { 0x8013136D, ("CORPROF_E_PROFILEE_PROCESS_NOT_FOUND", "AttachProfiler() was unable to find a profilee with the specified process ID.") },
            { 0x8013136E, ("CORPROF_E_CALLBACK3_REQUIRED", "Profiler must implement ICorProfilerCallback3 interface for this call to be supported.") },
            { 0x8013136F, ("CORPROF_E_UNSUPPORTED_FOR_ATTACHING_PROFILER", "This call was attempted by a profiler that attached to the process after startup, but this call is only supported by profilers that are loaded into the process on startup.") },
            { 0x80131370, ("CORPROF_E_IRREVERSIBLE_INSTRUMENTATION_PRESENT", "Detach is impossible because the profiler has either instrumented IL or inserted enter/leave hooks. Detach was not attempted; the profiler is still fully attached.") },
            { 0x80131371, ("CORPROF_E_RUNTIME_UNINITIALIZED", "The profiler called a function that cannot complete because the CLR is not yet fully initialized.  The profiler may try again once the CLR has fully started.") },
            { 0x80131372, ("CORPROF_E_IMMUTABLE_FLAGS_SET", "Detach is impossible because immutable flags were set by the profiler at startup. Detach was not attempted; the profiler is still fully attached.") },
            { 0x80131373, ("CORPROF_E_PROFILER_NOT_YET_INITIALIZED", "The profiler called a function that cannot complete because the profiler is not yet fully initialized.") },
            { 0x80131374, ("CORPROF_E_INCONSISTENT_WITH_FLAGS", "The profiler called a function that first requires additional flags to be set in the event mask.  This HRESULT may also indicate that the profiler called a function that first requires that some of the flags currently set in the event mask be reset.") },
            { 0x80131375, ("CORPROF_E_PROFILER_CANCEL_ACTIVATION", "The profiler has requested that the CLR instance not load the profiler into this process.") },
            { 0x80131376, ("CORPROF_E_CONCURRENT_GC_NOT_PROFILABLE", "Concurrent GC mode is enabled, which prevents use of COR_PRF_MONITOR_GC") },
            { 0x80131378, ("CORPROF_E_DEBUGGING_DISABLED", "This functionality requires CoreCLR debugging to be enabled.") },
            { 0x80131379, ("CORPROF_E_TIMEOUT_WAITING_FOR_CONCURRENT_GC", "Timed out on waiting for concurrent GC to finish during attach.") },
            { 0x8013137A, ("CORPROF_E_MODULE_IS_DYNAMIC", "The specified module was dynamically generated (e.g., via Reflection.Emit API), and is thus not supported by this API method.") },
            { 0x8013137B, ("CORPROF_E_CALLBACK4_REQUIRED", "Profiler must implement ICorProfilerCallback4 interface for this call to be supported.") },
            { 0x8013137C, ("CORPROF_E_REJIT_NOT_ENABLED", "This call is not supported unless ReJIT is first enabled during initialization by setting COR_PRF_ENABLE_REJIT via SetEventMask.") },
            { 0x8013137E, ("CORPROF_E_FUNCTION_IS_COLLECTIBLE", "The specified function is instantiated into a collectible assembly, and is thus not supported by this API method.") },
            { 0x80131380, ("CORPROF_E_CALLBACK6_REQUIRED", "Profiler must implement ICorProfilerCallback6 interface for this call to be supported.") },
            { 0x80131382, ("CORPROF_E_CALLBACK7_REQUIRED", "Profiler must implement ICorProfilerCallback7 interface for this call to be supported.") },
            { 0x80131383, ("CORPROF_E_REJIT_INLINING_DISABLED", "The runtime's tracking of inlined methods for ReJIT is not enabled.") },
            { 0x80131384, ("CORDIAGIPC_E_BAD_ENCODING", "The runtime was unable to decode the Header or Payload.") },
            { 0x80131385, ("CORDIAGIPC_E_UNKNOWN_COMMAND", "The specified CommandSet or CommandId is unknown.") },
            { 0x80131386, ("CORDIAGIPC_E_UNKNOWN_MAGIC", "The magic version of Diagnostics IPC is unknown.") },
            { 0x80131387, ("CORDIAGIPC_E_UNKNOWN_ERROR", "An unknown error occurred in the Diagnpostics IPC Server.") },
            { 0x80131388, ("CORPROF_E_SUSPENSION_IN_PROGRESS", "The runtime cannot be suspened since a suspension is already in progress.") },
            { 0x80131401, ("SECURITY_E_INCOMPATIBLE_SHARE", "Loading this assembly would produce a different grant set from other instances.") },
            { 0x80131402, ("SECURITY_E_UNVERIFIABLE", "Unverifiable code failed policy check.") },
            { 0x80131403, ("SECURITY_E_INCOMPATIBLE_EVIDENCE", "Assembly already loaded without additional security evidence.") },
            { 0x80131416, ("CORSEC_E_POLICY_EXCEPTION", "PolicyException thrown.") },
            { 0x80131417, ("CORSEC_E_MIN_GRANT_FAIL", "Failed to grant minimum permission requests.") },
            { 0x80131418, ("CORSEC_E_NO_EXEC_PERM", "Failed to grant permission to execute.") },
            { 0x80131419, ("CORSEC_E_XMLSYNTAX", "XML Syntax error.") },
            { 0x8013141a, ("CORSEC_E_INVALID_STRONGNAME", "Strong name validation failed.") },
            { 0x8013141b, ("CORSEC_E_MISSING_STRONGNAME", "Assembly is not strong named.") },
            { 0x8013141d, ("CORSEC_E_INVALID_IMAGE_FORMAT", "Invalid assembly file format.") },
            { 0x8013141e, ("CORSEC_E_INVALID_PUBLICKEY", "Invalid assembly public key.") },
            { 0x80131420, ("CORSEC_E_SIGNATURE_MISMATCH", "Signature size mismatch.") },
            { 0x80131430, ("CORSEC_E_CRYPTO", "Failure during Cryptographic operation.") },
            { 0x80131431, ("CORSEC_E_CRYPTO_UNEX_OPER", "Unexpected Cryptographic operation.") },
            { 0x80131442, ("CORSECATTR_E_BAD_ACTION", "Invalid security action code.") },
            { 0x80131500, ("COR_E_EXCEPTION", "General Exception") },
            { 0x80131501, ("COR_E_SYSTEM", "System.Exception") },
            { 0x80131502, ("COR_E_ARGUMENTOUTOFRANGE", "An argument was out of its legal range.") },
            { 0x80131503, ("COR_E_ARRAYTYPEMISMATCH", "Attempted to store an object of the wrong type in an array.") },
            { 0x80131504, ("COR_E_CONTEXTMARSHAL", "Attempted to marshal an object across a context boundary.") },
            { 0x80131505, ("COR_E_TIMEOUT", "Operation timed out.") },
            { 0x80131506, ("COR_E_EXECUTIONENGINE", "Internal CLR error.") },
            { 0x80131507, ("COR_E_FIELDACCESS", "Access to this field is denied.") },
            { 0x80131508, ("COR_E_INDEXOUTOFRANGE", "Array subscript out of range.") },
            { 0x80131509, ("COR_E_INVALIDOPERATION", "An operation is not legal in the current state.") },
            { 0x8013150a, ("COR_E_SECURITY", "An error relating to security occurred.") },
            { 0x8013150c, ("COR_E_SERIALIZATION", "An error relating to serialization occurred.") },
            { 0x8013150d, ("COR_E_VERIFICATION", "A verification failure has occurred.") },
            { 0x80131510, ("COR_E_METHODACCESS", "Access to this method is denied.") },
            { 0x80131511, ("COR_E_MISSINGFIELD", "Field does not exist.") },
            { 0x80131512, ("COR_E_MISSINGMEMBER", "Member does not exist.") },
            { 0x80131513, ("COR_E_MISSINGMETHOD", "Method does not exist.") },
            { 0x80131514, ("COR_E_MULTICASTNOTSUPPORTED", "Attempt to combine delegates that are not multicast.") },
            { 0x80131515, ("COR_E_NOTSUPPORTED", "Operation is not supported.") },
            { 0x80131516, ("COR_E_OVERFLOW", "Arithmetic, casting or conversion operation overflowed or underflowed.") },
            { 0x80131517, ("COR_E_RANK", "An array has the wrong number of dimensions for a particular operation.") },
            { 0x80131518, ("COR_E_SYNCHRONIZATIONLOCK", "This operation must be called from a synchronized block.") },
            { 0x80131519, ("COR_E_THREADINTERRUPTED", "Thread was interrupted from a waiting state.") },
            { 0x8013151a, ("COR_E_MEMBERACCESS", "Access to this member is denied.") },
            { 0x80131520, ("COR_E_THREADSTATE", "Thread is in an invalid state for this operation.") },
            { 0x80131521, ("COR_E_THREADSTOP", "Thread is stopping.") },
            { 0x80131522, ("COR_E_TYPELOAD", "Could not find or load a type.") },
            { 0x80131523, ("COR_E_ENTRYPOINTNOTFOUND", "Could not find the specified DllImport entrypoint.") },
            { 0x80131524, ("COR_E_DLLNOTFOUND", "Could not find the specified DllImport Dll.") },
            { 0x80131525, ("COR_E_THREADSTART", "Indicate that a user thread fails to start.") },
            { 0x80131527, ("COR_E_INVALIDCOMOBJECT", "An invalid __ComObject has been used.") },
            { 0x80131528, ("COR_E_NOTFINITENUMBER", "Not a Number.") },
            { 0x80131529, ("COR_E_DUPLICATEWAITOBJECT", "An object appears more than once in the wait objects array.") },
            { 0x8013152b, ("COR_E_SEMAPHOREFULL", "Reached maximum count for semaphore.") },
            { 0x8013152c, ("COR_E_WAITHANDLECANNOTBEOPENED", "No semaphore of the given name exists.") },
            { 0x8013152d, ("COR_E_ABANDONEDMUTEX", "The wait completed due to an abandoned mutex.") },
            { 0x80131530, ("COR_E_THREADABORTED", "Thread has aborted.") },
            { 0x80131531, ("COR_E_INVALIDOLEVARIANTTYPE", "OLE Variant has an invalid type.") },
            { 0x80131532, ("COR_E_MISSINGMANIFESTRESOURCE", "An expected resource in the assembly manifest was missing.") },
            { 0x80131533, ("COR_E_SAFEARRAYTYPEMISMATCH", "A mismatch has occurred between the runtime type of the array and the sub type recorded in the metadata.") },
            { 0x80131534, ("COR_E_TYPEINITIALIZATION", "Uncaught exception during type initialization.") },
            { 0x80131535, ("COR_E_MARSHALDIRECTIVE", "Invalid marshaling directives.") },
            { 0x80131536, ("COR_E_MISSINGSATELLITEASSEMBLY", "An expected satellite assembly containing the ultimate fallback resources for a given culture was not found or could not be loaded.") },
            { 0x80131537, ("COR_E_FORMAT", "The format of one argument does not meet the contract of the method.") },
            { 0x80131538, ("COR_E_SAFEARRAYRANKMISMATCH", "A mismatch has occurred between the runtime rank of the array and the rank recorded in the metadata.") },
            { 0x80131539, ("COR_E_PLATFORMNOTSUPPORTED", "Operation is not supported on this platform.") },
            { 0x8013153a, ("COR_E_INVALIDPROGRAM", "Invalid IL or CLR metadata.") },
            { 0x8013153b, ("COR_E_OPERATIONCANCELED", "The operation was cancelled.") },
            { 0x8013153d, ("COR_E_INSUFFICIENTMEMORY", "Not enough memory was available for an operation.") },
            { 0x8013153e, ("COR_E_RUNTIMEWRAPPED", "An object that does not derive from System.Exception has been wrapped in a RuntimeWrappedException.") },
            { 0x80131541, ("COR_E_DATAMISALIGNED", "A datatype misalignment was detected in a load or store instruction.") },
            { 0x80131542, ("COR_E_CODECONTRACTFAILED", "A managed code contract (ie, precondition, postcondition, invariant, or assert) failed.") },
            { 0x80131543, ("COR_E_TYPEACCESS", "Access to this type is denied.") },
            { 0x80131544, ("COR_E_ACCESSING_CCW", "Fail to access a CCW because the corresponding managed object is already collected.") },
            { 0x80131577, ("COR_E_KEYNOTFOUND", "The given key was not present in the dictionary.") },
            { 0x80131578, ("COR_E_INSUFFICIENTEXECUTIONSTACK", "Insufficient stack to continue executing the program safely. This can happen from having too many functions on the call stack or function on the stack using too much stack space.") },
            { 0x80131600, ("COR_E_APPLICATION", "Application exception") },
            { 0x80131601, ("COR_E_INVALIDFILTERCRITERIA", "The given filter criteria does not match the filter content.") },
            { 0x80131602, ("COR_E_REFLECTIONTYPELOAD", "Could not find or load a specific class that was requested through Reflection.") },
            { 0x80131603, ("COR_E_TARGET", "Attempt to invoke non-static method with a null Object.") },
            { 0x80131604, ("COR_E_TARGETINVOCATION", "Uncaught exception thrown by method called through Reflection.") },
            { 0x80131605, ("COR_E_CUSTOMATTRIBUTEFORMAT", "Custom attribute has invalid format.") },
            { 0x80131620, ("COR_E_IO", "Error during managed I/O.") },
            { 0x80131621, ("COR_E_FILELOAD", "Could not find or load a specific file.") },
            { 0x80131622, ("COR_E_OBJECTDISPOSED", "The object has already been disposed.") },
            { 0x80131623, ("COR_E_FAILFAST", "Runtime operation halted by call to System.Environment.FailFast().") },
            { 0x80131640, ("COR_E_HOSTPROTECTION", "The host has forbidden this operation.") },
            { 0x80131641, ("COR_E_ILLEGAL_REENTRANCY", "Attempted to call into managed code when executing inside a low level extensibility point.") },
            { 0x80131700, ("CLR_E_SHIM_RUNTIMELOAD", "Failed to load the runtime.") },
            { 0x80131704, ("CLR_E_SHIM_LEGACYRUNTIMEALREADYBOUND", "A runtime has already been bound for legacy activation policy use.") },
            { 0x80131815, ("VER_E_FIELD_SIG", "[field sig]") },
            { 0x801318ce, ("VER_E_CIRCULAR_VAR_CONSTRAINTS", "Method parent has circular class type parameter constraints.") },
            { 0x801318cf, ("VER_E_CIRCULAR_MVAR_CONSTRAINTS", "Method has circular method type parameter constraints.") },
            { 0x80131920, ("COR_E_Data", NoResourceStringMessage) },
            { 0x80131b24, ("VLDTR_E_SIG_BADVOID", "Illegal 'void' in signature.") },
            { 0x80131b2d, ("VLDTR_E_GP_ILLEGAL_VARIANT_MVAR", "GenericParam is a method type parameter and must be non-variant.") },
            { 0x80131c00, ("CORDBG_E_THREAD_NOT_SCHEDULED", "Thread is not scheduled. Thus we may not have OSThreadId, handle, or context.") },
            { 0x80131c01, ("CORDBG_E_HANDLE_HAS_BEEN_DISPOSED", "Handle has been disposed.") },
            { 0x80131c02, ("CORDBG_E_NONINTERCEPTABLE_EXCEPTION", "Cannot intercept this exception.") },
            { 0x80131c04, ("CORDBG_E_INTERCEPT_FRAME_ALREADY_SET", "The intercept frame for this exception has already been set.") },
            { 0x80131c05, ("CORDBG_E_NO_NATIVE_PATCH_AT_ADDR", "There is no native patch at the given address.") },
            { 0x80131c06, ("CORDBG_E_MUST_BE_INTEROP_DEBUGGING", "This API is only allowed when interop debugging.") },
            { 0x80131c07, ("CORDBG_E_NATIVE_PATCH_ALREADY_AT_ADDR", "There is already a native patch at the address.") },
            { 0x80131c08, ("CORDBG_E_TIMEOUT", "A wait timed out, likely an indication of deadlock.") },
            { 0x80131c09, ("CORDBG_E_CANT_CALL_ON_THIS_THREAD", "Cannot use the API on this thread.") },
            { 0x80131c0a, ("CORDBG_E_ENC_INFOLESS_METHOD", "Method was not JIT'd in EnC mode.") },
            { 0x80131c0c, ("CORDBG_E_ENC_IN_FUNCLET", "Method is in a callable handler/filter. Cannot increase stack.") },
            { 0x80131c0e, ("CORDBG_E_ENC_EDIT_NOT_SUPPORTED", "Attempt to perform unsupported edit.") },
            { 0x80131c10, ("CORDBG_E_NOTREADY", "The LS is not in a good spot to perform the requested operation.") },
            { 0x80131c11, ("CORDBG_E_CANNOT_RESOLVE_ASSEMBLY", "We failed to resolve assembly given an AssemblyRef token. Assembly may be not loaded yet or not a valid token.") },
            { 0x80131c12, ("CORDBG_E_MUST_BE_IN_LOAD_MODULE", "Must be in context of LoadModule callback to perform requested operation.") },
            { 0x80131c13, ("CORDBG_E_CANNOT_BE_ON_ATTACH", "Requested operation cannot be performed during an attach operation.") },
            { 0x80131c14, ("CORDBG_E_NGEN_NOT_SUPPORTED", "NGEN must be supported to perform the requested operation.") },
            { 0x80131c15, ("CORDBG_E_ILLEGAL_SHUTDOWN_ORDER", "Trying to shutdown out of order.") },
            { 0x80131c16, ("CORDBG_E_CANNOT_DEBUG_FIBER_PROCESS", "Debugging fiber mode managed process is not supported.") },
            { 0x80131c17, ("CORDBG_E_MUST_BE_IN_CREATE_PROCESS", "Must be in context of CreateProcess callback to perform requested operation.") },
            { 0x80131c18, ("CORDBG_E_DETACH_FAILED_OUTSTANDING_EVALS", "All outstanding func-evals have not completed, detaching is not allowed at this time.") },
            { 0x80131c19, ("CORDBG_E_DETACH_FAILED_OUTSTANDING_STEPPERS", "All outstanding steppers have not been closed, detaching is not allowed at this time.") },
            { 0x80131c20, ("CORDBG_E_CANT_INTEROP_STEP_OUT", "Cannot have an ICorDebugStepper do a native step-out.") },
            { 0x80131c21, ("CORDBG_E_DETACH_FAILED_OUTSTANDING_BREAKPOINTS", "All outstanding breakpoints have not been closed, detaching is not allowed at this time.") },
            { 0x80131c22, ("CORDBG_E_ILLEGAL_IN_STACK_OVERFLOW", "The operation is illegal because of a stack overflow.") },
            { 0x80131c23, ("CORDBG_E_ILLEGAL_AT_GC_UNSAFE_POINT", "The operation failed because it is a GC unsafe point.") },
            { 0x80131c24, ("CORDBG_E_ILLEGAL_IN_PROLOG", "The operation failed because the thread is in the prolog.") },
            { 0x80131c25, ("CORDBG_E_ILLEGAL_IN_NATIVE_CODE", "The operation failed because the thread is in native code.") },
            { 0x80131c26, ("CORDBG_E_ILLEGAL_IN_OPTIMIZED_CODE", "The operation failed because the thread is in optimized code.") },
            { 0x80131c28, ("CORDBG_E_APPDOMAIN_MISMATCH", "A supplied object or type belongs to the wrong AppDomain.") },
            { 0x80131c29, ("CORDBG_E_CONTEXT_UNVAILABLE", "The thread's context is not available.") },
            { 0x80131c30, ("CORDBG_E_UNCOMPATIBLE_PLATFORMS", "The operation failed because debuggee and debugger are on incompatible platforms.") },
            { 0x80131c31, ("CORDBG_E_DEBUGGING_DISABLED", "The operation failed because the debugging has been disabled") },
            { 0x80131c32, ("CORDBG_E_DETACH_FAILED_ON_ENC", "Detach is illegal after an Edit and Continue on a module.") },
            { 0x80131c33, ("CORDBG_E_CURRENT_EXCEPTION_IS_OUTSIDE_CURRENT_EXECUTION_SCOPE", "Cannot intercept the current exception at the specified frame.") },
            { 0x80131c34, ("CORDBG_E_HELPER_MAY_DEADLOCK", "The debugger helper thread cannot obtain the locks it needs to perform this operation.") },
            { 0x80131c35, ("CORDBG_E_MISSING_METADATA", "The operation failed because the debugger could not get the metadata.") },
            { 0x80131c36, ("CORDBG_E_TARGET_INCONSISTENT", "The debuggee is in a corrupt state.") },
            { 0x80131c37, ("CORDBG_E_DETACH_FAILED_OUTSTANDING_TARGET_RESOURCES", "Detach failed because there are outstanding resources in the target.") },
            { 0x80131c38, ("CORDBG_E_TARGET_READONLY", "The debuggee is read-only.") },
            { 0x80131c39, ("CORDBG_E_MISMATCHED_CORWKS_AND_DACWKS_DLLS", "The version of clr.dll in the target does not match the one mscordacwks.dll was built for.") },
            { 0x80131c3a, ("CORDBG_E_MODULE_LOADED_FROM_DISK", "Symbols are not supplied for modules loaded from disk.") },
            { 0x80131c3b, ("CORDBG_E_SYMBOLS_NOT_AVAILABLE", "The application did not supply symbols when it loaded or created this module, or they are not yet available.") },
            { 0x80131c3c, ("CORDBG_E_DEBUG_COMPONENT_MISSING", "A debug component is not installed.") },
            { 0x80131c43, ("CORDBG_E_LIBRARY_PROVIDER_ERROR", "The ICLRDebuggingLibraryProvider callback returned an error or did not provide a valid handle.") },
            { 0x80131c44, ("CORDBG_E_NOT_CLR", "The module at the base address indicated was not recognized as a CLR") },
            { 0x80131c45, ("CORDBG_E_MISSING_DATA_TARGET_INTERFACE", "The provided data target does not implement the required interfaces for this version of the runtime") },
            { 0x80131c46, ("CORDBG_E_UNSUPPORTED_DEBUGGING_MODEL", "This debugging model is unsupported by the specified runtime") },
            { 0x80131c47, ("CORDBG_E_UNSUPPORTED_FORWARD_COMPAT", "The debugger is not designed to support the version of the CLR the debuggee is using.") },
            { 0x80131c48, ("CORDBG_E_UNSUPPORTED_VERSION_STRUCT", "The version struct has an unrecognized value for wStructVersion") },
            { 0x80131c49, ("CORDBG_E_READVIRTUAL_FAILURE", "A call into a ReadVirtual implementation returned failure") },
            { 0x80131c4a, ("CORDBG_E_VALUE_POINTS_TO_FUNCTION", "The Debugging API doesn't support dereferencing function pointers.") },
            { 0x80131c4b, ("CORDBG_E_CORRUPT_OBJECT", "The address provided does not point to a valid managed object.") },
            { 0x80131c4c, ("CORDBG_E_GC_STRUCTURES_INVALID", "The GC heap structures are not in a valid state for traversal.") },
            { 0x80131c4d, ("CORDBG_E_INVALID_OPCODE", "The specified IL offset or opcode is not supported for this operation.") },
            { 0x80131c4e, ("CORDBG_E_UNSUPPORTED", "The specified action is unsupported by this version of the runtime.") },
            { 0x80131c4f, ("CORDBG_E_MISSING_DEBUGGER_EXPORTS", "The debuggee memory space does not have the expected debugging export table.") },
            { 0x80131c61, ("CORDBG_E_DATA_TARGET_ERROR", "Failure when calling a data target method.") },
            { 0x80131c64, ("CORDBG_E_NO_IMAGE_AVAILABLE", "Couldn't find a native image.") },
            { 0x80131c68, ("CORDBG_E_UNSUPPORTED_DELEGATE", "The delegate contains a delegate currently not supported by the API.") },
            { 0x80131d02, ("PEFMT_E_64BIT", "File is PE32+.") },
            { 0x80131d0b, ("PEFMT_E_32BIT", "File is PE32") },
            { 0x80131f06, ("NGEN_E_SYS_ASM_NI_MISSING", "NGen cannot proceed because Mscorlib.dll does not have a native image") },
            { 0x80131fff, ("CLDB_E_INTERNALERROR", NoResourceStringMessage) },
            { 0x80132000, ("CLR_E_BIND_ASSEMBLY_VERSION_TOO_LOW", "The bound assembly has a version that is lower than that of the request.") },
            { 0x80132001, ("CLR_E_BIND_ASSEMBLY_PUBLIC_KEY_MISMATCH", "The assembly version has a public key token that does not match that of the request.") },
            { 0x80132002, ("CLR_E_BIND_IMAGE_UNAVAILABLE", "The requested image was not found or is unavailable.") },
            { 0x80132003, ("CLR_E_BIND_UNRECOGNIZED_IDENTITY_FORMAT", "The provided identity format is not recognized.") },
            { 0x80132004, ("CLR_E_BIND_ASSEMBLY_NOT_FOUND", "A binding for the specified assembly name was not found.") },
            { 0x80132005, ("CLR_E_BIND_TYPE_NOT_FOUND", "A binding for the specified type name was not found.") },
            { 0x80132006, ("CLR_E_BIND_SYS_ASM_NI_MISSING", "Could not use native image because Mscorlib.dll is missing a native image") },
            { 0x80132007, ("CLR_E_BIND_NI_SECURITY_FAILURE", "Native image was generated in a different trust level than present at runtime") },
            { 0x80132008, ("CLR_E_BIND_NI_DEP_IDENTITY_MISMATCH", "Native image identity mismatch with respect to its dependencies") },
            { 0x80132009, ("CLR_E_GC_OOM", "Failfast due to an OOM during a GC") },
            { 0x8013200A, ("CLR_E_GC_BAD_AFFINITY_CONFIG", "GCHeapAffinitizeMask or GCHeapAffinitizeRanges didn't specify any CPUs the current process is affinitized to.") },
            { 0x8013200B, ("CLR_E_GC_BAD_AFFINITY_CONFIG_FORMAT", "GCHeapAffinitizeRanges configuration string has invalid format.") },
            { 0x8013200C, ("CLR_E_CROSSGEN_NO_IBC_DATA_FOUND", "Cannot compile using the PartialNgen flag because no IBC data was found.") },
            { 0x80070005, ("COR_E_UNAUTHORIZEDACCESS", "Access is denied.") },
            { 0x80070057, ("COR_E_ARGUMENT", "An argument does not meet the contract of the method.") },
            { 0x80004002, ("COR_E_INVALIDCAST", "Indicates a bad cast condition") },
            { 0x8007000E, ("COR_E_OUTOFMEMORY", "The EE thows this exception when no more memory is avaible to continue execution") },
            { 0x80004003, ("COR_E_NULLREFERENCE", "Dereferencing a null reference. In general class libraries should not throw this") },
            { 0x80070216, ("COR_E_ARITHMETIC", "Overflow or underflow in mathematical operations.") },
            { 0x800700CE, ("COR_E_PATHTOOLONG", "The specified path was too long.") },
            { 0x80070002, ("COR_E_FILENOTFOUND", "The system cannot find the file specified.") },
            { 0x80070026, ("COR_E_ENDOFSTREAM", "Attempted to read past the end of the stream.") },
            { 0x80070003, ("COR_E_DIRECTORYNOTFOUND", "The specified path couldn't be found.") },
            { 0x800703E9, ("COR_E_STACKOVERFLOW", "Is raised by the EE when the execution stack overflows as it is attempting to ex") },
            { 0x8000211D, ("COR_E_AMBIGUOUSMATCH", "While late binding to a method via reflection, could not resolve between") },
            { 0x8002000E, ("COR_E_TARGETPARAMCOUNT", "There was a mismatch between number of arguments provided and the number expected") },
            { 0x80020012, ("COR_E_DIVIDEBYZERO", "Attempted to divide a number by zero.") },
            { 0x8007000B, ("COR_E_BADIMAGEFORMAT", "The format of a DLL or executable being loaded is invalid.") },
        };
    }
}
